#!/usr/bin/env python

import sys,pwd,os
import argparse
import gpbs
import time
import commands

## =============================================================================
## class to store the commands
## =============================================================================

class Command(object):
  '''
Description
-----------

Store a (series of) command(s) to run to submit a job. Use this class only when
no PBS-file is used.
  '''

  # ----------------------------------------------------------------------------
  # class constructor
  # ----------------------------------------------------------------------------

  def __init__(self,command):

    # store the command
    self.command = command

    # store information about the job
    self.nodes = lambda: int(command.split('nodes=')[1].split(':')[0])
    self.ppn   = lambda: int(command.split('ppn='  )[1].split(':')[0])
    self.ctype = lambda:     command.split('ppn='  )[1].split(':')[1].split(':')[0].split(' ')[0]
    # perform the extraction in a more robust way
    for key in ['nodes','ctype','ppn']:
      try:
        setattr(self,key,getattr(self,key)())
      except:
        setattr(self,key,None)
    for key in ['ctype']:
      if getattr(self,key) is not None:
        if len(getattr(self,key))==0:
          setattr(self,key,None)

  # ----------------------------------------------------------------------------
  # command to submit
  # ----------------------------------------------------------------------------

  def submit(self):
    '''
Return the command to submit the job. If the job cannot be specified, "False"
is returned.
    '''

    # read the node information
    on    = ['free','job-exclusive']
    nodes = [i for i in gpbs.pbsRead(ganglia=False) if i.state in on]

    # limit to node-type
    if self.ctype is not None:
      nodes = [i for i in nodes if i.ctype==self.ctype]

    # extract CPUs that have the minimum number of CPUs free
    if self.ppn is not None:
      nodes = [i for i in nodes if i.cpufree>self.ppn]

    # check availability
    if len(nodes)==0:
      return False
    else:
      return self.command

## =============================================================================
## class to store the job options
## =============================================================================

class Job(object):
  '''
Description
-----------

Store a job in the form of a PBS-file. This class reads the specified resources,
checks the availability, and optionally increase them.

Input arguments
---------------

**fname** = ``<str>``

  Name of the PBS-file. E.g.::

    sim000/submit.pbs
    submit.pbs

Input options
-------------

**resource** = ``<list>``

  A list with resources that are used to overwrite these resources specified in
  the PBS-file.

**maxppn** = [``False``] | ``True``

  Allows to increase the number of CPUs up to the maximum available.
  '''

  # ----------------------------------------------------------------------------
  # class constructor
  # ----------------------------------------------------------------------------

  def __init__(self,fname,resource=None,name=None,maxppn=False):

    # store the file-name
    self.fname    = fname
    self.name     = name
    self.resource = resource
    self.maxppn   = maxppn

    # read PBS-file to extract options
    text = open(fname,'r').read()

    # extract name
    if self.name is None or self.name=='%s':
      if len(text.split('#PBS -N'))>1:
        self.name = text.split('#PBS -N')[1].split('\n')[0].strip()
      else:
        self.name = os.path.split(fname)[-2]

    # extract resource settings
    if self.resource is None:
      if len(text.split('#PBS -l'))>1:
        self.resource = [text.split('#PBS -l')[1].split('\n')[0].strip()]
      else:
        self.resource = ['nodes=1:ppn=1:intel']

    # extract parameters for each job
    res        = '::'.join(self.resource)+':'
    self.nodes = lambda: int(res.split('nodes=')[1].split(':')[0])
    self.ppn   = lambda: int(res.split('ppn='  )[1].split(':')[0])
    self.ctype = lambda:     res.split('ppn='  )[1].split(':')[1].split(':')[0]
    self.disk  = lambda:     res.split('file=' )[1].split(':')[0]
    # perform the extraction in a more robust way
    for key in ['nodes','ctype','ppn','disk']:
      try:
        setattr(self,key,getattr(self,key)())
      except:
        setattr(self,key,None)
    for key in ['ctype']:
      if getattr(self,key) is not None:
        if len(getattr(self,key))==0:
          setattr(self,key,None)

    # remove the "file" option, this is an error in the queuing system
    self.resource = [i for i in self.resource if len(i.split('file='))==1]

    # split the name of the file and folder
    if len(self.fname.split('/'))>1:
      self.cd    = '/'.join(self.fname.split('/')[:-1])
      self.fname = self.fname.split('/')[-1]
      self.root  = '/'.join(['..' for i in self.cd.split('/')])
    else:
      self.cd    = None
      self.root  = None
      self.name  = None

    if self.nodes!=1:
      raise RuntimeError('Not yet accounted for')

  # ----------------------------------------------------------------------------
  # return command to submit
  # ----------------------------------------------------------------------------

  def submit(self):
    '''
Return the command to submit the job. If the job cannot be specified, "False"
is returned.
    '''

    # read the node information
    on    = ['free','job-exclusive']
    nodes = [i for i in gpbs.pbsRead(ganglia=False) if i.state in on]

    # limit to node-type
    if self.ctype is not None:
      nodes = [i for i in nodes if i.ctype==self.ctype]

    # extract CPUs that have the minimum number of CPUs free
    if self.ppn is not None:
      nodes = [i for i in nodes if i.cpufree>=self.ppn]

    # sort the nodes based on CPU availability
    if self.maxppn:
      nodes = sorted(nodes,key=lambda node: node.cpufree)[-1::-1]

    # check availability
    if len(nodes)==0:
      return False

    # select the nodes on which to run, optionally accounting for the free
    # disk space of "/state/partition1"
    if self.disk is None:
      node = nodes[0]
    else:
      for i,node in enumerate(nodes):
        # get the disk space on the node
        df = commands.getoutput("ssh %s 'df -h' | grep /state/partition1"%node.name)
        df = ' '.join(df.split()).split('/dev')[1].split(' ')[3]
        # stop the loop of the disk space is sufficient
        if gpbs.Data(string=self.disk)<gpbs.Data(string=df):
          break
        # quit is none of the nodes have enough disk space
        if i==len(nodes)-1:
          return False

    # initiate the command
    cmd = ['qsub']
    # add name if specified
    if self.name is not None:
      cmd += ['-N '+self.name]
    # add resource options is specified
    if self.resource is not None:
      if not self.maxppn and self.disk is None:
        cmd += ['-l '+i for i in self.resource]
      elif not self.maxppn:
        cmd += ['-l '+i.replace('nodes=1','nodes=%s'%node.name) for i in self.resource]
      else:
        cmd += ['-l '+i.replace('nodes=1','nodes=%s'%node.name).replace('ppn=%d'%self.ppn,'ppn=%d'%node.cpufree) for i in self.resource]
    # combine command
    cmd += [self.fname]
    cmd  = ' '.join(cmd)
    if self.cd is not None:
      cmd = 'cd %s; %s; cd %s'%(self.cd,cmd,self.root)

    return cmd

## =============================================================================
## class to keep track of the running jobs
## =============================================================================

class Running(object):
  '''
Description
-----------

This class stores a list of jobs (by job-id). Upon using the ``len`` command
this class update the list of jobs against the running jobs.

Input options
-------------

**jobs** = ``<list>``

  List with job-id's.

**mode** = ["current"] | "total"

  If set to "current", the list with jobs is updated by removing all the
  completed jobs. If set to "total" the list is updated with all the user's
  jobs that are currently running.
  '''

  # ----------------------------------------------------------------------------
  # class constructor
  # ----------------------------------------------------------------------------

  def __init__(self,jobs=[],mode='current'):
    self.jobs = jobs
    self.mode = mode

  # ----------------------------------------------------------------------------
  # number of running jobs
  # ----------------------------------------------------------------------------

  def __len__(self):
    self.refresh()
    return len(self.jobs)

  # ----------------------------------------------------------------------------
  # add job
  # ----------------------------------------------------------------------------

  def __add__(self,jid):
    self.jobs += [jid]
    return self

  # ----------------------------------------------------------------------------
  # refresh running jobs
  # ----------------------------------------------------------------------------

  def refresh(self):

    if self.mode=='current':

      # get all jobs, as job-id
      jobs = gpbs.qstatRead()
      jobs = [job.id for job in jobs]

      # correct the list of running jobs
      self.jobs = [i for i in self.jobs if i in jobs]

    elif self.mode=='total':

      # read user name
      uname = pwd.getpwuid(os.getuid())[0]

      # get the user's jobs
      jobs      = gpbs.qstatRead()
      self.jobs = [job.id for job in jobs if job.owner==uname]

## =============================================================================
## main command-line interaction
## =============================================================================

if __name__=='__main__':

  # ----------------------------------------------------------------------------
  # define argument parser
  # ----------------------------------------------------------------------------

  def printhelp():
    print '''
================
File-based input
================

Usage
-----

$ qauto [OPTIONS] FILE.PBS [FILE.PBS ...]

Description
-----------

Automatically submit PBS-jobs defined in the PBS-files. This function:

1. Changes the current directory to that of the PBS-file.
2. Runs: "qsub FILE.PBS".
3. Changes back to the directory from which this command is run.

For each job (file in the list of supplied files). Jobs are only submitted if
the number of jobs is sufficiently small. Otherwise the function sleeps until a
space is opened up.

Options
-------

-n, --jobs: N

  Maximum number of jobs running in parallel. Default: 72.

-c, --check: "current" | "all"

  Base the maximum number of jobs based on the "current" batch of jobs or
  "all" the user's jobs. Default: "current".

-s, --sleep: T

  Specify sleep duration if the job cannot be directly submitted.

-w, --wait: T

  Specify time to wait between submitting two jobs.

-l, --resource: PBS-OPTIONS

  Specify PBS-resource-options that overwrite the options in the PBS-files. For
  example:

    nodes=1:ppn=1:intel
    file=20gb

  Default (if not otherwise specified): "nodes=1:ppn=1:intel"

--maxppn

  Maximize the number of CPUs per node, based on availability. The specified
  number of nodes is taken as a minimum. For example, to run on minimum 6 CPUs
  in parallel on intel or amd:

    qauto -l nodes=1:ppn=6 --maxppn FILE.PBS

-N, --name: NAME

  Select name of the submitted jobs. If set to "%s" the folder name is used.
  Default (if not otherwise specified): "%s".

===================
Command based input
===================

Usage
-----

$ cat commands.log | qauto [OPTIONS]

Description
-----------

Pipe a list of commands (separated by a new-line) to the qauto-function. This
function executes the commands if the number of running jobs is sufficiently
small. NB: in this mode the function does not interpret or modifies the
PBS-directives. I.e. the optimization options such as above cannot be applied
in this mode.

Options
-------

-n, --jobs: N

  Maximum number of jobs running in parallel. Default: 72.

-c, --check: "current" | "all"

  Base the maximum number of jobs based on the "current" batch of jobs or
  "all" the user's jobs. Default: "current"

========
Examples
========

Maximum number of CPUs
----------------------

To run on at least 7 CPUs (intel/amd), but only if the disk space is sufficient:

  $ qauto -n 10 -l nodes=1:ppn=7 -l file=40gb --maxppn */*.pbs
    '''
    raise SystemExit(0)

  # define parser and CL-options
  parser = argparse.ArgumentParser(add_help=False)
  args   = [\
    ( ['-h','--help'    ] , dict(action='store_true'              ) ),
    ( ['-n','--jobs'    ] , dict(type=int,default=72              ) ),
    ( ['-c','--check'   ] , dict(type=str,default='current'       ) ),
    ( ['-s','--sleep'   ] , dict(type=float,default=None          ) ),
    ( ['-w','--wait'    ] , dict(type=float,default=None          ) ),
    ( ['-l','--resource'] , dict(type=str,nargs=1,action='append' ) ),
    ( ['-N','--name'    ] , dict(type=str,nargs=1                 ) ),
    ( [     '--maxppn'  ] , dict(action='store_true'              ) ),
  ]
  # add options to the parser
  for (arg,opt) in args:
    parser.add_argument(*arg,**opt)
  # add arguments to the parse
  parser.add_argument('files',metavar='F',type=str,nargs='*')

  # parse the command line
  args = vars(parser.parse_args())

  # print help and exit
  if args['help']:
    printhelp()

  # convert list definition
  for name in ['resource']:
    if args[name] is not None:
      args[name] = [i[0] for i in args[name]]
  for name in ['name']:
    if args[name] is not None:
      args[name] = args[name][0]

  # convert input to class: a different class is used for input commands than
  # for input files
  if len(args['files'])==0:
    jobs = [Command(i.rstrip()) for i in sys.stdin]
  else:
    jobs = [Job(i,args['resource'],args['name'],args['maxppn']) for i in args['files']]

  # set default wait time
  if args['maxppn'] and args['wait'] is None:
    args['wait'] = 2.0
  elif args['wait'] is None:
    args['wait'] = 0.2

  # set default sleep time
  if args['sleep'] is None:
    args['sleep'] = 60.0
    if args['resource'] is not None:
      if len([True for i in args['resource'] if len(i.split('file='))>1])>0:
        args['sleep'] = 360.0

  # ----------------------------------------------------------------------------
  # submit jobs
  # ----------------------------------------------------------------------------

  # initiate running jobs
  running = Running(mode=args['check'])

  # loop over jobs to submit
  for job in jobs:

    # wait until a spot becomes available
    while len(running)>=args['jobs'] or not job.submit():
      time.sleep(args['sleep'])

    # submit job
    jid = commands.getoutput(job.submit())
    print job.submit(),jid
    running += int(jid.split('.')[0])

    time.sleep(args['wait'])
