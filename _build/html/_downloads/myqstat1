#!/share/apps/extra/python/bin/python
#
# Change log
# ----------
#
#  Version 3.0.0, April 2014, [TdG]
#    - use "argparse" for command-line-interaction
#    - changed options:
#       "-m"  removed: replace by "-u" without arguments
#    - use "gpbs" to parse the output of the "qstat -f", "pbsnodes"
#      and "ganglia" commands
#
#  Version 2.4.2, August 2013
#    - add filter options in summary modes [TdG]
#
#  Version 2.4.1, August 2013
#    - added sort options for 'pbsnodes' summary [TdG]
#
#  Version 2.4, August 2013
#    - code clean-up [TdG]
#    - modified option: -v version number, and --version changelog [TdG]
#    - add --sort option: m: sort by memory, s: sort state [TdG]
#    - added option (un-documented): --debug; the program then accepts two input
#      arguments, the file-name of files that contain the output of the
#      `qstat -f` and the `pbsnodes` commands respectively [TdG]
#
#  Version 2.3, July 2013
#    - added option: -m print only user's job
#      (equivalent to myqstat -u `whoami`) [JN]
#
#  Version 2.2, April 2013
#    - adapted column width to screen size [TdG]
#    - modified options: introduced -U and -N as summary options [TdG]
#
#  Version 2.1
#    - incorporated the `pbsnodes` command to generate summaries [TdG]
#    - changed data classes [TdG]
#
#  Version 2.0
#    - extended filter options [TdG]
#    - changed code to the Python (in stead of Bash) programming language [TdG]
#
#  Version 1.2
#    - implemented filter functionality [TdG]
#
#  Version 1.1
#    - extended with computer readable output [TdG]
#
#  Version 1.0
#    - first version [JN]
#
#  Possible extensions:
#    - extend help on regexp [JN]
#
#  Editors
#    [TdG]  T.W.J. de Geus (Tom)
#    [JN]   J. Neggers (Jan)


import gpbs

# set version information
__version__ = '3.0.0'

# ==============================================================================
# command-line interaction
# ==============================================================================

def printhelp():

  import sys

  print '''
NAME

  myqstat - display the formatted output of the 'qstat -f'

USAGE

  $ myqstat [options]

DESCRIPTION

  Display the essential information from the 'qstat -f' command, compactly
  formatted (similar to the default 'qstat' output). The number of columns and
  their width are adapted to the screen size (see output options below).

OPTIONS

  General options
   -h --help          print help
   -v --version       print program version number

  Filter options
   -u --user [opt]    user filter (default `whoami`)    [re]
   -j --jobname [arg] job-name filter                   [re]
   -i --id [arg]      job-id filter                     [re]
   -t --time [arg]    walltime filter, e.g. ">10d"      [quotes]
   -n --node [arg]    host filter, e.g. "10" or ">10"   [quotes]
   -r --regexp        filter [re] options using regular expressions

  Ouput options
   -c --columns [arg] specify output columns explicitly (see below)
   -s --sort [arg]    sort the output along a certain column (see below)
      --order         sort the output (a)scending or (d)escending
   -o --output [arg]  output style: (s)hort, (l)ong, (c)omputer readable
      --noheader      do not display header

 Summary options
   -U --user-summary  summary per user
   -N --node-summary  summary per node (wrapper around pbsnodes)
      --long          additional node information (slow, as it scans nodes)

  Output columns
   i   id             -
   o   owner          -
   n   job name       -
   h   host           compute-node number
   c   cpus           CPU resources claimed
   m   mem            memory currently used by the job
   p   pmem           requested memory
   s   S              state (Q=queued, R=running)
   t   time           walltime (elapsed time since the job has started)
   s   score          score: CPU-time / ( walltime * #CPUs )

  Output columns [--node-summary]
   n   node           compute-node number
   s   state          status (free,job-exclusive,offline,down)
   t   type           CPU-type (amd,intel)
   c   Ctot           #CPUs
   u   Cused          #CPUs in use by jobs
   f   Cfree          #CPUs free
   l   score          load (~job score)
   m   Mtot           physical memory present in the node
   w   Mused          memory currently used by jobs
   r   Mrel           ratio of memory used by jobs (>1: swapping, avoid!)

  Output columns [--node-summary --long]
   h   HDtot          total amount of disk-space in the node
   e   HDused         amount of disk-space currently used
   x   HD%            ratio of disk-space used by jobs (>1 jobs get killed)
   b   Network        total network traffic

  Output columns [--user-summary]
   o   owner          -
   c   cpus           total number of CPUs in use by the owner
   a   amd            total number of AMDs in use by the owner
   i   intel          total number of Intels in use by the owner
   m   mem            total memory used by the owner
   t   time           total walltime of all owner's jobs
   s   score          average score of all owner's jobs

RELEASE

  Version 3.0, May 2014

COPYRIGHT

  T.W.J. de Geus

ACKNOWLEDGMENT

  J. Neggers
  '''
  sys.exit(0)

def commandline():

  import argparse
  import os,pwd

  ### set IO options/arguments ###

  # set input options
  opts = [\
    (('-h','--help'        ),dict(action='store_true'             )),\
    (('-v','--version'     ),dict(action='store_true'             )),\
    (('-u','--user'        ),dict(nargs='*',type=str              )),\
    (('-j','--jobname'     ),dict(nargs='+',type=str              )),\
    (('-n','--node'        ),dict(nargs='+',type=str              )),\
    (('-i','--id'          ),dict(nargs='+',type=str              )),\
    (('-t','--time'        ),dict(nargs='+',type=str              )),\
    (('-r','--regexp'      ),dict(action='store_true'             )),\
    (('-s','--sort'        ),dict(nargs='+',type=str              )),\
    ((     '--order'       ),dict(nargs=1  ,type=str,default='a'  )),\
    (('-o','--output'      ),dict(nargs=1  ,type=str,default='s'  )),\
    (('-c','--columns'     ),dict(nargs='+',type=str              )),\
    ((     '--noheader'    ),dict(action='store_true'             )),\
    (('-U','--user-summary'),dict(action='store_true'             )),\
    (('-N','--node-summary'),dict(action='store_true'             )),\
    ((     '--long'        ),dict(action='store_true'             )),\
    ((     '--debug'       ),dict(action='store_true'             )),\
  ]

  ### parse actual command line arguments ###

  # create argument parser
  parser = argparse.ArgumentParser(add_help=False)
  for (arg,opt) in opts:
    if type(arg)==tuple:
      parser.add_argument(*arg,**opt)
    else:
      parser.add_argument(arg,**opt)
  # read arguments from command-line
  args = vars(parser.parse_args())

  # print help and exit
  if args['help']:
    printhelp()

  ### additional checking and defaults ###

  # change format: list -> str
  for key in ['columns','order']:
    if args[key] is not None:
      args[key] = args[key][0]
  # change format: str -> list (e.g. "io" -> ["i","o"]
  if args['sort'] is not None:
    if len(args['sort'])==1:
      args['sort'] = list(args['sort'][0])

  # set exclusive options
  excl = [\
    ('user_summary','node_summary'),\
  ]
  # check exclusive options
  msg = '"--%s" and "--%s" options are exclusive, consult "myqstat --help"'
  for opt in excl:
    if len([True for i in opt if args[i]])>1:
      raise parser.error(msg%tuple([i.replace('_','-') for i in opt]))

  # set defaults, other than assigned by parser
  if args['user'] is not None:
    if len(args['user'])==0:
      args['user'] = [pwd.getpwuid(os.getuid())[0]]

  # combine options to shorten implementation
  args['mode'] = 'qstat'
  if args['user_summary']: args['mode'] = 'user'
  if args['node_summary']: args['mode'] = 'node'

  # for filters that are specified but not as regular expressions: convert
  for field in ['user','jobname','id']:
    if args[field] is not None:
      if not args['regexp']:
        args[field] = ['^'+i+'$' for i in args[field]]

  return args

# ==============================================================================
# sort list according to CLI-arguments
# ==============================================================================

def sort(data,alias,args,function):
  '''
Sort a list (of dictionaries, classes, etc.), according to different aliases
in "args['sort']". The "function" is a lambda function that is used to reduce
the list of types to a list that can be sorted. The order of sort can be
reduced using the "args['order']" option.
  '''

  if args['sort']:

    # loop over expressions
    for expr in args['sort']:
      if expr not in alias:
        raise IOError('Unknown sort key %s'%expr)

      # define list to sort
      li = function(expr)

      # sort
      ind = [i for _,i in sorted((v,i) for i,v in enumerate(li))]

      # reverse order
      if args['order']=='d':
        ind = ind[::-1]

      # apply sort
      data = [data[i] for i in ind]

  return data

# ==============================================================================
# formatted print output
# ==============================================================================

# support function to get the size of the terminal
# see: http://www.codingtiger.com/questions/linux/
#      How-to-get-console-window-width-in-python.html
def getTerminalSize():
  """
    returns (lines:int, cols:int)
    """
  import os, struct
  def ioctl_GWINSZ(fd):
    import fcntl, termios
    return struct.unpack("hh", fcntl.ioctl(fd, termios.TIOCGWINSZ, "1234"))
  # try stdin, stdout, stderr
  for fd in (0, 1, 2):
    try:
      return ioctl_GWINSZ(fd)
    except:
      pass
  # try os.ctermid()
  try:
    fd = os.open(os.ctermid(), os.O_RDONLY)
    try:
      return ioctl_GWINSZ(fd)
    finally:
      os.close(fd)
  except:
    pass
  # try `stty size`
  try:
    return tuple(int(x) for x in os.popen("stty size", "r").read().split())
  except:
    pass
  # try environment variables
  try:
    return tuple(int(os.getenv(var)) for var in ("LINES", "COLUMNS"))
  except:
    pass
  # i give up. return default.
  return (25, 80)

# ------------------------------------------------------------------------------

def dataPrint(output,alias,data,args,sep=', ',trunc=' ...',trunf='...'):
  '''
Description
-----------

Formatted print to the screen.

Input arguments
---------------

**alias** = ``dict``

  Dictionary with an alias to select columns. E.g. alias['o'] = 'owner'

**data** = ``list``

  List of dictionaries with the data to print to the screen.

**args** = ``dict``

  Command-line options/arguments.

Input options
-------------

**sep** = ", "

  Column separator.

**trunc** = " ..."

  String to denote the truncation of columns.

**trunf** = "..."

  String to denote the truncation of fields.
  '''

  # general try/except statement to avoid errors when end for example the
  # "watch" command with "ctrl-c"
  try:

    # set default: all columns included
    # if set to "False" the "trunc" string is added right of the columns
    columns = True

    # select fields bases on command-line input
    if args['columns'] is not None:
      # check
      for i in args['columns']:
        if i not in alias:
          raise IOError('Unknown column key %s'%i)
      # select columns based on string
      output = {alias[i]:output[alias[i]] for i in args['columns']}
      for (i,name) in enumerate(args['columns']):
        output[alias[name]]['col'] = i

    # calculate the width of the:
    for field in output:
      # - header
      output[field]['whead'] = len(output[field]['head'])
      # - body (information of the `qstat -f` command)
      wmax = 0
      for dat in data:
        wmax = max(wmax,len(dat[field]))
      # and calculate the maximum of the two, also set as default column width
      output[field]['wcol'] = max(wmax,output[field]['whead'])
      output[field]['wmax'] = max(wmax,output[field]['whead'])

    # for short output: determine whether to truncate columns
    if args['output']=='s':

      # get the width needed to print all columns
      wtot = sum([output[i]['wcol'] for i in output])+(len(output)-1)*len(sep)
      # get the width of the current window
      wwin = getTerminalSize()[1]
      # if no truncation is needed: skip truncation (equiv. to long output)
      if ( wtot < wwin ):
        args['output'] = 'l'

    # proceed with truncation
    if args['output']=='s':

      ### remove columns if needed

      # set columns in order of importance
      fields = sorted(output, key=lambda key: output[key]['rel'])
      # leave room for truncation
      wmax = wwin-len(trunc)
      # continue adding columns with the minimum width until the screen is filled
      wtot    = 0
      include = []
      for field in fields:
        if ( output[field]['wmin'] < (wmax-wtot-len(sep)) ):
          output[field]['wcol'] = output[field]['wmin']
          include.append(field)
          wtot += output[field]['wcol']+len(sep)
      # delete fields that are no longer included, and update the list of fields
      # in order of importance
      if len(include)!=len(fields):
        output  = {k:v for (k,v) in output.items() if k in include}
        fields  = sorted(output, key=lambda key: output[key]['rel'])
        wwin   -= len(trunc)
        columns = False

      ### extend each of the columns as far as needed, but at maximum to the
      ### screen width

      # extend to columns to fill the view
      for field in fields:
        # check the total length
        wtot = sum([output[i]['wcol'] for i in output])+(len(output)-1)*len(sep)
        if wtot>=wwin:
          break
        # extend the column
        output[field]['wcol'] = \
          min(output[field]['wmax'],(output[field]['wcol']+wwin-wtot))

      # if fields are cut: add truncation string to the fields that are cut
      for field in output:
        for dat in data:
          if len(dat[field])>output[field]['wcol']:
            dat[field] = dat[field][:(output[field]['wcol']-len(trunf))]+trunf

    # for computer readable format set the column width to format the header line
    if args['output']=='c':
      sep = ','
      for field in output:
        output[field]['wcol'] = output[field]['whead']
        output[field]['fmt']  = '%s'
    # set the print template for formatted print
    else:
      for field in output:
        alg = output[field]['align']
        wdt = str(output[field]['wcol'])
        output[field]['fmt'] = '%'+alg+wdt+'.'+wdt+'s'

    # set the columns in the order such as specified
    fields = sorted(output, key=lambda key: output[key]['col'])

    # concatenate print template to one string
    fmt = sep.join([output[i]['fmt'] for i in fields])

    # print the header
    if not args['noheader']:
      # change alignment
      hfmt = fmt.replace('%-','%').replace('%','%-')
      # add truncation symbol
      if not columns:
        hfmt += trunc
      # print
      print hfmt % tuple([output[i]['head']     for i in fields])
      print fmt  % tuple(['-'*output[i]['wcol'] for i in fields])

    # print the jobs
    for dat in data:
      print fmt % tuple([dat[i] for i in fields])

  except:
    pass

# ==============================================================================
# pbsnodes output
# ==============================================================================

def pbsnodes(args,pbs=None,ganlia=None):
  '''
Control formatted print for the "-N" option.
  '''

  # read command output
  if args['long']:
    nodes = gpbs.pbsRead(pbsnodes=pbs,ganglia=ganlia)
  else:
    nodes = gpbs.pbsRead(pbsnodes=pbs,ganglia=False)

  # summarize node information
  summary = gpbs.pbsSummary(nodes)

  # set command-line aliases [options: -s/-c]
  alias = {}
  alias['n'] = 'node'
  alias['s'] = 'state'
  alias['t'] = 'ctype'
  alias['c'] = 'ncpu'
  alias['u'] = 'njobs'
  alias['f'] = 'cpufree'
  alias['l'] = 'load'
  alias['m'] = 'memp'
  alias['w'] = 'memu'
  alias['r'] = 'memr'
  alias['h'] = 'disk_total'
  alias['e'] = 'disk_used'
  alias['x'] = 'disk_rel'
  alias['b'] = 'bytes_tot'

  # set default sort
  if args['sort'] is None:
    args['sort'] = ['n']
  # set list of nodes
  if args['sort']:
    nodes = sort(nodes,alias,args,lambda expr: [i[alias[expr]] for i in nodes])

  # output settings
  output = {}
  output['node'   ] = dict(head='Node' ,wmin=4,align='',col=0,rel=0)
  output['state'  ] = dict(head='State',wmin=6,align='',col=1,rel=1)
  output['ctype'  ] = dict(head='Type' ,wmin=5,align='',col=2,rel=2)
  output['ncpu'   ] = dict(head='Ctot' ,wmin=4,align='',col=3,rel=3)
  output['njobs'  ] = dict(head='Cused',wmin=5,align='',col=4,rel=4)
  output['cpufree'] = dict(head='Cfree',wmin=5,align='',col=5,rel=5)
  output['load'   ] = dict(head='Score',wmin=5,align='',col=6,rel=6)
  output['memp'   ] = dict(head='Mtot' ,wmin=5,align='',col=7,rel=7)
  output['memu'   ] = dict(head='Mused',wmin=6,align='',col=8,rel=8)
  output['memr'   ] = dict(head='Mem%' ,wmin=5,align='',col=9,rel=9)
  if args['long']:
    output['disk_total'] = dict(head='HDtot'  ,wmin=6,align='',col=10,rel=10)
    output['disk_used' ] = dict(head='HDused' ,wmin=6,align='',col=11,rel=11)
    output['disk_rel'  ] = dict(head='HD%'    ,wmin=5,align='',col=12,rel=12)
    output['bytes_tot' ] = dict(head='Network',wmin=7,align='',col=13,rel=13)


  # convert jobs to dictionary with only strings
  for node in nodes:
    for key in output:
      node[key] = str(node[key])

  # formatted output
  dataPrint(output,alias,nodes,args,sep=', ')

  # get summary
  out = []
  out.append('number of CPUs total    : %3d ( %3d amd / %3d intel )' %
    tuple([summary['total'  ][i] for i in ['total','amd','intel']]))
  out.append('number of CPUs offline  : %3d ( %3d amd / %3d intel )' %
    tuple([summary['offline'][i] for i in ['total','amd','intel']]))
  out.append('number of CPUs online   : %3d ( %3d amd / %3d intel )' %
    tuple([summary['online' ][i] for i in ['total','amd','intel']]))
  out.append('number of CPUs working  : %3d ( %3d amd / %3d intel )' %
    tuple([summary['njobs'  ][i] for i in ['total','amd','intel']]))
  out.append('number of CPUs free     : %3d ( %3d amd / %3d intel )' %
    tuple([summary['cpufree'][i] for i in ['total','amd','intel']]))
  # print summary
  print '-'*53
  print '\n'.join(out)

# ==============================================================================
# qstat output
# ==============================================================================

def qstat(args,text=None):
  '''
Control formatted print.
  '''

  # load job information
  jobs = gpbs.qstatRead(text)

  # set list with command-line argument aliases [options: -u/-j/-i/-n/-t]
  alias = {}
  alias['user'   ] = 'owner'
  alias['jobname'] = 'name'
  alias['id'     ] = 'id'
  alias['node'   ] = 'host'
  alias['time'   ] = 'walltime'
  # loop over filters
  for name in ['user','jobname','id','time','node']:
    # proceed with filter only if the filter is specified
    if args[name] is not None:
      # initiate to include or not
      incl = [False for i in jobs]
      # loop over jobs
      for (ijob,job) in enumerate(jobs):
        incl[ijob] = any([job[alias[name]]==i for i in args[name]])
      # select jobs
      jobs = [job for job,i in zip(jobs,incl) if i]

  # set command-line aliases [options: -s/-c]
  alias = {}
  alias['i'] = 'id'
  alias['o'] = 'owner'
  alias['n'] = 'name'
  alias['h'] = 'host'
  alias['c'] = 'resnode'
  alias['p'] = 'pmem'
  alias['m'] = 'memused'
  alias['s'] = 'state'
  alias['t'] = 'walltime'
  alias['s'] = 'score'

  # set list of jobs
  if args['sort']:
    jobs = sort(jobs,alias,args,lambda expr: [i[alias[expr]] for i in jobs])

  # output settings
  output = {}
  output['id'      ] = dict(head='id'      ,wmin=6,align='' ,col=0,rel=0)
  output['owner'   ] = dict(head='owner'   ,wmin=7,align='-',col=1,rel=2)
  output['name'    ] = dict(head='job name',wmin=5,align='-',col=2,rel=9)
  output['host'    ] = dict(head='host'    ,wmin=2,align='' ,col=3,rel=3)
  output['resnode' ] = dict(head='cpus'    ,wmin=4,align='' ,col=4,rel=5)
  output['memused' ] = dict(head='mem'     ,wmin=5,align='' ,col=5,rel=4)
  output['pmem' ]    = dict(head='pmem'    ,wmin=4,align='' ,col=6,rel=8)
  output['state'   ] = dict(head='S'       ,wmin=1,align='-',col=7,rel=1)
  output['walltime'] = dict(head='time'    ,wmin=5,align='' ,col=8,rel=6)
  output['score'   ] = dict(head='score'   ,wmin=5,align='' ,col=9,rel=7)

  # convert jobs to dictionary with only strings
  for job in jobs:
    for key in output:
      job[key] = str(job[key])

  # formatted output
  dataPrint(output,alias,jobs,args)

# ==============================================================================
# user summay
# ==============================================================================

def user_summary(args,qstat=None,pbs=None):
  '''
Control formatted print for the "-U" option.
  '''

  # load job information "[gpbs.Job]", and node information "[gpbs.Node]"
  jobs  = gpbs.qstatRead(qstat)
  nodes = gpbs.pbsRead(pbsnodes=pbs,ganglia=False)
  # user summary, and node summary: "dict"
  owners = gpbs.qstatSummary(jobs,nodes)
  nodes  = gpbs.pbsSummary(nodes)

  # set command-line aliases [options: -s/-c]
  alias = {}
  alias['o'] = 'owner'
  alias['c'] = 'total'
  alias['a'] = 'amd'
  alias['i'] = 'intel'
  alias['m'] = 'memused'
  alias['t'] = 'walltime'
  alias['s'] = 'score'

  # set default sort
  if args['sort'] is None:
    args['sort'] = ['c']
  # sort list of user-summary
  if args['sort']:
    owners = sort(owners,alias,args,lambda expr: [i[alias[expr]] for i in owners])

  # convert qstat-summary to string
  for i in owners:
    # convert number of CPUs to string, include fraction
    for n in ['total','amd','intel']:
      i[n] = '%3d (%3d%s)'%(i[n],float(i[n])/float(nodes['online'][n])*100.,'%')
    for n in ['memused','walltime','score']:
      i[n] = str(i[n])

  # output settings
  output = {}
  output['owner'   ] = dict(head='owner' ,wmin=7 ,align='-',col=0,rel=0)
  output['total'   ] = dict(head='cpus'  ,wmin=10,align='' ,col=1,rel=1)
  output['amd'     ] = dict(head='amd'   ,wmin=10,align='' ,col=2,rel=3)
  output['intel'   ] = dict(head='intel' ,wmin=10,align='' ,col=3,rel=4)
  output['memused' ] = dict(head='mem'   ,wmin=5 ,align='' ,col=4,rel=5)
  output['walltime'] = dict(head='time'  ,wmin=5 ,align='' ,col=5,rel=6)
  output['score'   ] = dict(head='score' ,wmin=5 ,align='' ,col=6,rel=2)

  # formatted output
  dataPrint(output,alias,owners,args,sep=' , ')

# ==============================================================================
# main program
# ==============================================================================

if __name__=='__main__':

  # read command line options
  args = commandline()

  # initiate variables [debugging]
  qstatf  = None
  pbs     = None
  ganglia = None
  # input files [debugging only]
  if args['debug']:
    qstatf  = open('qstat.log'   ,'r').read()
    pbs     = open('pbsnodes.log','r').read()
    ganglia = open('ganglia.log' ,'r').read()

  # run different modes
  if args['mode']=='qstat':
    qstat(args,qstatf)
  elif args['mode']=='node':
    pbsnodes(args,pbs,ganglia)
  elif args['mode']=='user':
    user_summary(args,qstatf,pbs)

