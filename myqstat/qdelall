#!/usr/bin/env python

import argparse,time
import commands,os,pwd,sys,re
import gpbs

# ==============================================================================

def version():
  print '''
Version 0.1
  '''
  sys.exit(0)


def help():
  print '''
NAME

  qdelall - delete a group of PBS-jobs

USAGE

  $ qdelall [-n NAME] [-i ID] [-s STATE] [-t] [-v] [-c]

DESCRIPTION

  Delete a group of PBS-jobs (or all the user's jobs).

OPTIONS

  -h, --help
    Print help

  --version
    Print version

  -v, --verbose
    Verbose operations, ask for conformation.

  -n, --name=STR
    Filter by name, may be regular expression (e.g. "dir.*file.ext").

  -i, --id=STR
    Filter by job-id, may be regular expression.

  -s, --state=STR
    Filter by state, e.g.: 'Q', 'R'.

  -t, --tempdir
    Remove temporary working directory.

  -c, --copy=DIR
    Copy the data from the temporary directory before deleting the job (and
    removing it, if the option "-t" is also used). If no directory is specified
    the directory of the output-file is used.

SEE ALSO

  gpbs - PBS-wrapper in Python

RELEASE

  Version 0.1, December 2015

FEATURES REQUESTED

  - Copy the files from the compute-node back to the head-node [experimental].
  - Make verbose more explicit: explicitly list the commands.

COPYRIGHT

  T.W.J. de Geus
  '''

  sys.exit(0)

# ==============================================================================

# ------------------------------------------------------------------------------
# prompt user configuration
# ------------------------------------------------------------------------------

def confirm(prompt):
  '''
Prompt the user for confirmation.

:arguments:

  **prompt** (``<str>``)
    Message to prompt the user.

:return:

  **response** (``True`` | ``False``)
    The user's answer.
  '''

  prompt = '%s\ny/n?\n'%prompt

  while True:

    user = raw_input(prompt)

    if not user:
      print 'please enter y or n.'
      continue

    if user not in ['y', 'Y', 'n', 'N']:
      print 'please enter y or n.'
      continue

    if user == 'y' or user == 'Y':
      return True

    if user == 'n' or user == 'N':
      return False

# ------------------------------------------------------------------------------
# parse command-line arguments
# ------------------------------------------------------------------------------

# set options/arguments
opts = [\
  (('-h','--help'   ),dict(action='store_true'             )),
  ((     '--version'),dict(action='store_true'             )),
  (('-t','--tempdir'),dict(action='store_true'             )),
  (('-v','--verbose'),dict(action='store_true'             )),
  (('-c','--copy'   ),dict(nargs='?',type=str,default=False)),
  (('-n','--name'   ),dict(nargs='+',type=str              )),
  (('-s','--state'  ),dict(nargs='+',type=str              )),
  (('-i','--id'     ),dict(nargs='+',type=str              )),
]

# parse command-line arguments
# - create parser
parser = argparse.ArgumentParser(add_help=False)
for (arg,opt) in opts:
  if type(arg)==tuple: parser.add_argument(*arg,**opt)
  else               : parser.add_argument( arg,**opt)
# - execute parser / convert to "<dict>"
args = vars(parser.parse_args())
# - convert to string
for key in ['name','id']:
  if type(args[key])==list:
    args[key] = [re.compile('^'+item+'$') for item in args[key]]
for key in ['state']:
  if type(args[key])==list:
    args[key] = [re.compile('^'+item.upper()+'$') for item in args[key]]

# print help and exit
if args['help']:
  help()
if args['version']:
  version()

# ------------------------------------------------------------------------------
# main program
# ------------------------------------------------------------------------------

# select the jobs
# ---------------

# read all of the user's jobs
user = pwd.getpwuid(os.getuid())[0]
jobs = [job for job in gpbs.read_qstat() if job.owner==user]

# filter the jobs by: id, name, state
if args['id'   ] is not None: jobs =[[job for job in jobs if re.match(item,job.id   )] for item in args['id'   ]]; jobs = [job for sub in jobs for job in sub]
if args['name' ] is not None: jobs =[[job for job in jobs if re.match(item,job.name )] for item in args['name' ]]; jobs = [job for sub in jobs for job in sub]
if args['state'] is not None: jobs =[[job for job in jobs if re.match(item,job.state)] for item in args['state']]; jobs = [job for sub in jobs for job in sub]

# optionally ask for confirmation
# -------------------------------

if args['verbose']:
  # calculate width of the columns to align
  keys = ['id','owner','name']
  N    = [0 for key in keys]
  for ikey,key in enumerate(keys):
    for job in jobs:
      N[ikey] = max(N[ikey],len(str(getattr(job,key))))
  fmt  = '{id:%ds} {owner:%ds} {name:%ds}'%tuple(N)
  # create message
  message = 'Delete the following jobs?\n'+'\n'.join([fmt.format(**vars(job)) for job in jobs])
  if not confirm(message):
    sys.exit(0)

# delete the jobs
# ---------------

# split queued and not-queued jobs
queued = [job.id for job in jobs if job.state=='Q']
jobs   = [job    for job in jobs if job.state!='Q']

# delete queued jobs at once
commands.getoutput('qdel '+' '.join(queued))

# delete jobs
for job in jobs:

  # delete job
  commands.getoutput('qdel '+job.id)

  # copy the data from the temporary working directory
  if args['copy']!=False and re.match('[0-9]+',str(job.host)):

    if   type(args['copy'])==str    : dest = args['copy']
    elif job.output_path is not None: dest = os.path.dirname(job.output_path)
    else                            : print '--copy: unknown destination'; sys.exit(1)

    commands.getoutput("scp -r {node:s}:{temp:s}/* {dest:s}/".format(
      node = 'compute-0-'+str(job.host),
      temp = gpbs.script.tempdir.format(user=user,jobid=job.id),
      dest = dest,
    ))

  # remove temporary working directory
  if args['tempdir'] and re.match('[0-9]+',str(job.host)):

    commands.getoutput("ssh {node:s} 'rm -r {temp:s}'".format(
      node = 'compute-0-'+str(job.host),
      temp = gpbs.script.tempdir.format(user=user,jobid=job.id),
    ))